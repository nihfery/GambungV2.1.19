import "./chunk-MMN2DTB3.js";

// node_modules/connectkit/node_modules/family/lib/index-DD_kndDs.js
function _mergeNamespaces(n, m) {
  m.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(n);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var postRobot$1 = { exports: {} };
var postRobot = { exports: {} };
(function(module, exports) {
  !(function(root, factory) {
    module.exports = factory();
  })("undefined" != typeof self ? self : commonjsGlobal, (function() {
    return (function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        __webpack_require__.o(exports2, name) || Object.defineProperty(exports2, name, {
          enumerable: true,
          get: getter
        });
      };
      __webpack_require__.r = function(exports2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports2, Symbol.toStringTag, {
          value: "Module"
        });
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
      };
      __webpack_require__.t = function(value, mode) {
        1 & mode && (value = __webpack_require__(value));
        if (8 & mode) return value;
        if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", {
          enumerable: true,
          value
        });
        if (2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
          return value[key2];
        }).bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function() {
          return module2.default;
        } : function() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return {}.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 0);
    })([function(module2, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, "Promise", (function() {
        return promise_ZalgoPromise;
      }));
      __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
        return src_types_TYPES_0;
      }));
      __webpack_require__.d(__webpack_exports__, "ProxyWindow", (function() {
        return window_ProxyWindow;
      }));
      __webpack_require__.d(__webpack_exports__, "setup", (function() {
        return setup;
      }));
      __webpack_require__.d(__webpack_exports__, "destroy", (function() {
        return destroy;
      }));
      __webpack_require__.d(__webpack_exports__, "serializeMessage", (function() {
        return setup_serializeMessage;
      }));
      __webpack_require__.d(__webpack_exports__, "deserializeMessage", (function() {
        return setup_deserializeMessage;
      }));
      __webpack_require__.d(__webpack_exports__, "createProxyWindow", (function() {
        return createProxyWindow;
      }));
      __webpack_require__.d(__webpack_exports__, "toProxyWindow", (function() {
        return setup_toProxyWindow;
      }));
      __webpack_require__.d(__webpack_exports__, "on", (function() {
        return on_on;
      }));
      __webpack_require__.d(__webpack_exports__, "once", (function() {
        return on_once;
      }));
      __webpack_require__.d(__webpack_exports__, "send", (function() {
        return send_send;
      }));
      __webpack_require__.d(__webpack_exports__, "markWindowKnown", (function() {
        return markWindowKnown;
      }));
      __webpack_require__.d(__webpack_exports__, "cleanUpWindow", (function() {
        return cleanUpWindow;
      }));
      __webpack_require__.d(__webpack_exports__, "bridge", (function() {
      }));
      function isRegex(item) {
        return "[object RegExp]" === {}.toString.call(item);
      }
      var IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
      function getActualProtocol(win) {
        void 0 === win && (win = window);
        return win.location.protocol;
      }
      function getProtocol(win) {
        void 0 === win && (win = window);
        if (win.mockDomain) {
          var protocol = win.mockDomain.split("//")[0];
          if (protocol) return protocol;
        }
        return getActualProtocol(win);
      }
      function isAboutProtocol(win) {
        void 0 === win && (win = window);
        return "about:" === getProtocol(win);
      }
      function getParent(win) {
        void 0 === win && (win = window);
        if (win) try {
          if (win.parent && win.parent !== win) return win.parent;
        } catch (err) {
        }
      }
      function getOpener(win) {
        void 0 === win && (win = window);
        if (win && !getParent(win)) try {
          return win.opener;
        } catch (err) {
        }
      }
      function canReadFromWindow(win) {
        try {
          return true;
        } catch (err) {
        }
        return false;
      }
      function getActualDomain(win) {
        void 0 === win && (win = window);
        var location = win.location;
        if (!location) throw new Error("Can not read window location");
        var protocol = getActualProtocol(win);
        if (!protocol) throw new Error("Can not read window protocol");
        if ("file:" === protocol) return "file://";
        if ("about:" === protocol) {
          var parent = getParent(win);
          return parent && canReadFromWindow() ? getActualDomain(parent) : "about://";
        }
        var host = location.host;
        if (!host) throw new Error("Can not read window host");
        return protocol + "//" + host;
      }
      function getDomain(win) {
        void 0 === win && (win = window);
        var domain = getActualDomain(win);
        return domain && win.mockDomain && 0 === win.mockDomain.indexOf("mock:") ? win.mockDomain : domain;
      }
      function isSameDomain(win) {
        if (!(function(win2) {
          try {
            if (win2 === window) return true;
          } catch (err) {
          }
          try {
            var desc = Object.getOwnPropertyDescriptor(win2, "location");
            if (desc && false === desc.enumerable) return false;
          } catch (err) {
          }
          try {
            if (isAboutProtocol(win2) && canReadFromWindow()) return true;
          } catch (err) {
          }
          try {
            if ((function(win3) {
              void 0 === win3 && (win3 = window);
              return "mock:" === getProtocol(win3);
            })(win2) && canReadFromWindow()) return true;
          } catch (err) {
          }
          try {
            if (getActualDomain(win2) === getActualDomain(window)) return true;
          } catch (err) {
          }
          return false;
        })(win)) return false;
        try {
          if (win === window) return true;
          if (isAboutProtocol(win) && canReadFromWindow()) return true;
          if (getDomain(window) === getDomain(win)) return true;
        } catch (err) {
        }
        return false;
      }
      function assertSameDomain(win) {
        if (!isSameDomain(win)) throw new Error("Expected window to be same domain");
        return win;
      }
      function isAncestorParent(parent, child) {
        if (!parent || !child) return false;
        var childParent = getParent(child);
        return childParent ? childParent === parent : -1 !== (function(win) {
          var result = [];
          try {
            for (; win.parent !== win; ) {
              result.push(win.parent);
              win = win.parent;
            }
          } catch (err) {
          }
          return result;
        })(child).indexOf(parent);
      }
      function getFrames(win) {
        var result = [];
        var frames;
        try {
          frames = win.frames;
        } catch (err) {
          frames = win;
        }
        var len;
        try {
          len = frames.length;
        } catch (err) {
        }
        if (0 === len) return result;
        if (len) {
          for (var i = 0; i < len; i++) {
            var frame = void 0;
            try {
              frame = frames[i];
            } catch (err) {
              continue;
            }
            result.push(frame);
          }
          return result;
        }
        for (var _i = 0; _i < 100; _i++) {
          var _frame = void 0;
          try {
            _frame = frames[_i];
          } catch (err) {
            return result;
          }
          if (!_frame) return result;
          result.push(_frame);
        }
        return result;
      }
      var iframeWindows = [];
      var iframeFrames = [];
      function isWindowClosed(win, allowMock) {
        void 0 === allowMock && (allowMock = true);
        try {
          if (win === window) return false;
        } catch (err) {
          return true;
        }
        try {
          if (!win) return true;
        } catch (err) {
          return true;
        }
        try {
          if (win.closed) return true;
        } catch (err) {
          return !err || err.message !== IE_WIN_ACCESS_ERROR;
        }
        if (allowMock && isSameDomain(win)) try {
          if (win.mockclosed) return true;
        } catch (err) {
        }
        try {
          if (!win.parent || !win.top) return true;
        } catch (err) {
        }
        var iframeIndex = (function(collection, item) {
          for (var i = 0; i < collection.length; i++) try {
            if (collection[i] === item) return i;
          } catch (err) {
          }
          return -1;
        })(iframeWindows, win);
        if (-1 !== iframeIndex) {
          var frame = iframeFrames[iframeIndex];
          if (frame && (function(frame2) {
            if (!frame2.contentWindow) return true;
            if (!frame2.parentNode) return true;
            var doc = frame2.ownerDocument;
            if (doc && doc.documentElement && !doc.documentElement.contains(frame2)) {
              var parent = frame2;
              for (; parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;
              if (!parent.host || !doc.documentElement.contains(parent.host)) return true;
            }
            return false;
          })(frame)) return true;
        }
        return false;
      }
      function getAncestor(win) {
        void 0 === win && (win = window);
        return getOpener(win = win || window) || getParent(win) || void 0;
      }
      function matchDomain(pattern, origin) {
        if ("string" == typeof pattern) {
          if ("string" == typeof origin) return "*" === pattern || origin === pattern;
          if (isRegex(origin)) return false;
          if (Array.isArray(origin)) return false;
        }
        return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {
          return matchDomain(subpattern, origin);
        })));
      }
      function isWindow(obj) {
        try {
          if (obj === window) return true;
        } catch (err) {
          if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
        }
        try {
          if ("[object Window]" === {}.toString.call(obj)) return true;
        } catch (err) {
          if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
        }
        try {
          if (window.Window && obj instanceof window.Window) return true;
        } catch (err) {
          if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
        }
        try {
          if (obj && obj.self === obj) return true;
        } catch (err) {
          if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
        }
        try {
          if (obj && obj.parent === obj) return true;
        } catch (err) {
          if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
        }
        try {
          if (obj && obj.top === obj) return true;
        } catch (err) {
          if (err && err.message === IE_WIN_ACCESS_ERROR) return true;
        }
        try {
          if (obj && "__unlikely_value__" === obj.__cross_domain_utils_window_check__) return false;
        } catch (err) {
          return true;
        }
        try {
          if ("postMessage" in obj && "self" in obj && "location" in obj) return true;
        } catch (err) {
        }
        return false;
      }
      function getFrameForWindow(win) {
        if (isSameDomain(win)) return assertSameDomain(win).frameElement;
        for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll("iframe"); _i21 < _document$querySelect2.length; _i21++) {
          var frame = _document$querySelect2[_i21];
          if (frame && frame.contentWindow && frame.contentWindow === win) return frame;
        }
      }
      function closeWindow(win) {
        if ((function(win2) {
          void 0 === win2 && (win2 = window);
          return Boolean(getParent(win2));
        })(win)) {
          var frame = getFrameForWindow(win);
          if (frame && frame.parentElement) {
            frame.parentElement.removeChild(frame);
            return;
          }
        }
        try {
          win.close();
        } catch (err) {
        }
      }
      function utils_isPromise(item) {
        try {
          if (!item) return false;
          if ("undefined" != typeof Promise && item instanceof Promise) return true;
          if ("undefined" != typeof window && "function" == typeof window.Window && item instanceof window.Window) return false;
          if ("undefined" != typeof window && "function" == typeof window.constructor && item instanceof window.constructor) return false;
          var _toString = {}.toString;
          if (_toString) {
            var name = _toString.call(item);
            if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return false;
          }
          if ("function" == typeof item.then) return true;
        } catch (err) {
          return false;
        }
        return false;
      }
      var dispatchedErrors = [];
      var possiblyUnhandledPromiseHandlers = [];
      var activeCount = 0;
      var flushPromise;
      function flushActive() {
        if (!activeCount && flushPromise) {
          var promise = flushPromise;
          flushPromise = null;
          promise.resolve();
        }
      }
      function startActive() {
        activeCount += 1;
      }
      function endActive() {
        activeCount -= 1;
        flushActive();
      }
      var promise_ZalgoPromise = (function() {
        function ZalgoPromise(handler) {
          var _this = this;
          this.resolved = void 0;
          this.rejected = void 0;
          this.errorHandled = void 0;
          this.value = void 0;
          this.error = void 0;
          this.handlers = void 0;
          this.dispatching = void 0;
          this.stack = void 0;
          this.resolved = false;
          this.rejected = false;
          this.errorHandled = false;
          this.handlers = [];
          if (handler) {
            var _result;
            var _error;
            var resolved = false;
            var rejected = false;
            var isAsync = false;
            startActive();
            try {
              handler((function(res) {
                if (isAsync) _this.resolve(res);
                else {
                  resolved = true;
                  _result = res;
                }
              }), (function(err) {
                if (isAsync) _this.reject(err);
                else {
                  rejected = true;
                  _error = err;
                }
              }));
            } catch (err) {
              endActive();
              this.reject(err);
              return;
            }
            endActive();
            isAsync = true;
            resolved ? this.resolve(_result) : rejected && this.reject(_error);
          }
        }
        var _proto = ZalgoPromise.prototype;
        _proto.resolve = function(result) {
          if (this.resolved || this.rejected) return this;
          if (utils_isPromise(result)) throw new Error("Can not resolve promise with another promise");
          this.resolved = true;
          this.value = result;
          this.dispatch();
          return this;
        };
        _proto.reject = function(error) {
          var _this2 = this;
          if (this.resolved || this.rejected) return this;
          if (utils_isPromise(error)) throw new Error("Can not reject promise with another promise");
          if (!error) {
            var _err = error && "function" == typeof error.toString ? error.toString() : {}.toString.call(error);
            error = new Error("Expected reject to be called with Error, got " + _err);
          }
          this.rejected = true;
          this.error = error;
          this.errorHandled || setTimeout((function() {
            _this2.errorHandled || (function(err, promise) {
              if (-1 === dispatchedErrors.indexOf(err)) {
                dispatchedErrors.push(err);
                setTimeout((function() {
                  throw err;
                }), 1);
                for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);
              }
            })(error, _this2);
          }), 1);
          this.dispatch();
          return this;
        };
        _proto.asyncReject = function(error) {
          this.errorHandled = true;
          this.reject(error);
          return this;
        };
        _proto.dispatch = function() {
          var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
          if (!this.dispatching && (resolved || rejected)) {
            this.dispatching = true;
            startActive();
            var chain = function(firstPromise, secondPromise) {
              return firstPromise.then((function(res) {
                secondPromise.resolve(res);
              }), (function(err) {
                secondPromise.reject(err);
              }));
            };
            for (var i = 0; i < handlers.length; i++) {
              var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;
              var _result2 = void 0;
              if (resolved) try {
                _result2 = onSuccess ? onSuccess(this.value) : this.value;
              } catch (err) {
                promise.reject(err);
                continue;
              }
              else if (rejected) {
                if (!onError) {
                  promise.reject(this.error);
                  continue;
                }
                try {
                  _result2 = onError(this.error);
                } catch (err) {
                  promise.reject(err);
                  continue;
                }
              }
              if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {
                var promiseResult = _result2;
                promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);
                promiseResult.errorHandled = true;
              } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);
            }
            handlers.length = 0;
            this.dispatching = false;
            endActive();
          }
        };
        _proto.then = function(onSuccess, onError) {
          if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
          if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
          var promise = new ZalgoPromise();
          this.handlers.push({
            promise,
            onSuccess,
            onError
          });
          this.errorHandled = true;
          this.dispatch();
          return promise;
        };
        _proto.catch = function(onError) {
          return this.then(void 0, onError);
        };
        _proto.finally = function(onFinally) {
          if (onFinally && "function" != typeof onFinally && !onFinally.call) throw new Error("Promise.finally expected a function");
          return this.then((function(result) {
            return ZalgoPromise.try(onFinally).then((function() {
              return result;
            }));
          }), (function(err) {
            return ZalgoPromise.try(onFinally).then((function() {
              throw err;
            }));
          }));
        };
        _proto.timeout = function(time, err) {
          var _this3 = this;
          if (this.resolved || this.rejected) return this;
          var timeout = setTimeout((function() {
            _this3.resolved || _this3.rejected || _this3.reject(err || new Error("Promise timed out after " + time + "ms"));
          }), time);
          return this.then((function(result) {
            clearTimeout(timeout);
            return result;
          }));
        };
        _proto.toPromise = function() {
          if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
          return Promise.resolve(this);
        };
        _proto.lazy = function() {
          this.errorHandled = true;
          return this;
        };
        ZalgoPromise.resolve = function(value) {
          return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {
            return value.then(resolve, reject);
          })) : new ZalgoPromise().resolve(value);
        };
        ZalgoPromise.reject = function(error) {
          return new ZalgoPromise().reject(error);
        };
        ZalgoPromise.asyncReject = function(error) {
          return new ZalgoPromise().asyncReject(error);
        };
        ZalgoPromise.all = function(promises) {
          var promise = new ZalgoPromise();
          var count = promises.length;
          var results = [].slice();
          if (!count) {
            promise.resolve(results);
            return promise;
          }
          var chain = function(i2, firstPromise, secondPromise) {
            return firstPromise.then((function(res) {
              results[i2] = res;
              0 == (count -= 1) && promise.resolve(results);
            }), (function(err) {
              secondPromise.reject(err);
            }));
          };
          for (var i = 0; i < promises.length; i++) {
            var prom = promises[i];
            if (prom instanceof ZalgoPromise) {
              if (prom.resolved) {
                results[i] = prom.value;
                count -= 1;
                continue;
              }
            } else if (!utils_isPromise(prom)) {
              results[i] = prom;
              count -= 1;
              continue;
            }
            chain(i, ZalgoPromise.resolve(prom), promise);
          }
          0 === count && promise.resolve(results);
          return promise;
        };
        ZalgoPromise.hash = function(promises) {
          var result = {};
          var awaitPromises = [];
          var _loop = function(key2) {
            if (promises.hasOwnProperty(key2)) {
              var value = promises[key2];
              utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {
                result[key2] = res;
              }))) : result[key2] = value;
            }
          };
          for (var key in promises) _loop(key);
          return ZalgoPromise.all(awaitPromises).then((function() {
            return result;
          }));
        };
        ZalgoPromise.map = function(items, method) {
          return ZalgoPromise.all(items.map(method));
        };
        ZalgoPromise.onPossiblyUnhandledException = function(handler) {
          return (function(handler2) {
            possiblyUnhandledPromiseHandlers.push(handler2);
            return {
              cancel: function() {
                possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler2), 1);
              }
            };
          })(handler);
        };
        ZalgoPromise.try = function(method, context, args) {
          if (method && "function" != typeof method && !method.call) throw new Error("Promise.try expected a function");
          var result;
          startActive();
          try {
            result = method.apply(context, args || []);
          } catch (err) {
            endActive();
            return ZalgoPromise.reject(err);
          }
          endActive();
          return ZalgoPromise.resolve(result);
        };
        ZalgoPromise.delay = function(_delay) {
          return new ZalgoPromise((function(resolve) {
            setTimeout(resolve, _delay);
          }));
        };
        ZalgoPromise.isPromise = function(value) {
          return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);
        };
        ZalgoPromise.flush = function() {
          return (function(Zalgo) {
            var promise = flushPromise = flushPromise || new Zalgo();
            flushActive();
            return promise;
          })(ZalgoPromise);
        };
        return ZalgoPromise;
      })();
      function util_safeIndexOf(collection, item) {
        for (var i = 0; i < collection.length; i++) try {
          if (collection[i] === item) return i;
        } catch (err) {
        }
        return -1;
      }
      var weakmap_CrossDomainSafeWeakMap = (function() {
        function CrossDomainSafeWeakMap() {
          this.name = void 0;
          this.weakmap = void 0;
          this.keys = void 0;
          this.values = void 0;
          this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__";
          if ((function() {
            if ("undefined" == typeof WeakMap) return false;
            if (void 0 === Object.freeze) return false;
            try {
              var testWeakMap = /* @__PURE__ */ new WeakMap();
              var testKey = {};
              Object.freeze(testKey);
              testWeakMap.set(testKey, "__testvalue__");
              return "__testvalue__" === testWeakMap.get(testKey);
            } catch (err) {
              return false;
            }
          })()) try {
            this.weakmap = /* @__PURE__ */ new WeakMap();
          } catch (err) {
          }
          this.keys = [];
          this.values = [];
        }
        var _proto = CrossDomainSafeWeakMap.prototype;
        _proto._cleanupClosedWindows = function() {
          var weakmap = this.weakmap;
          var keys = this.keys;
          for (var i = 0; i < keys.length; i++) {
            var value = keys[i];
            if (isWindow(value) && isWindowClosed(value)) {
              if (weakmap) try {
                weakmap.delete(value);
              } catch (err) {
              }
              keys.splice(i, 1);
              this.values.splice(i, 1);
              i -= 1;
            }
          }
        };
        _proto.isSafeToReadWrite = function(key) {
          return !isWindow(key);
        };
        _proto.set = function(key, value) {
          if (!key) throw new Error("WeakMap expected key");
          var weakmap = this.weakmap;
          if (weakmap) try {
            weakmap.set(key, value);
          } catch (err) {
            delete this.weakmap;
          }
          if (this.isSafeToReadWrite(key)) try {
            var name = this.name;
            var entry = key[name];
            entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {
              value: [key, value],
              writable: true
            });
            return;
          } catch (err) {
          }
          this._cleanupClosedWindows();
          var keys = this.keys;
          var values = this.values;
          var index2 = util_safeIndexOf(keys, key);
          if (-1 === index2) {
            keys.push(key);
            values.push(value);
          } else values[index2] = value;
        };
        _proto.get = function(key) {
          if (!key) throw new Error("WeakMap expected key");
          var weakmap = this.weakmap;
          if (weakmap) try {
            if (weakmap.has(key)) return weakmap.get(key);
          } catch (err) {
            delete this.weakmap;
          }
          if (this.isSafeToReadWrite(key)) try {
            var entry = key[this.name];
            return entry && entry[0] === key ? entry[1] : void 0;
          } catch (err) {
          }
          this._cleanupClosedWindows();
          var index2 = util_safeIndexOf(this.keys, key);
          if (-1 !== index2) return this.values[index2];
        };
        _proto.delete = function(key) {
          if (!key) throw new Error("WeakMap expected key");
          var weakmap = this.weakmap;
          if (weakmap) try {
            weakmap.delete(key);
          } catch (err) {
            delete this.weakmap;
          }
          if (this.isSafeToReadWrite(key)) try {
            var entry = key[this.name];
            entry && entry[0] === key && (entry[0] = entry[1] = void 0);
          } catch (err) {
          }
          this._cleanupClosedWindows();
          var keys = this.keys;
          var index2 = util_safeIndexOf(keys, key);
          if (-1 !== index2) {
            keys.splice(index2, 1);
            this.values.splice(index2, 1);
          }
        };
        _proto.has = function(key) {
          if (!key) throw new Error("WeakMap expected key");
          var weakmap = this.weakmap;
          if (weakmap) try {
            if (weakmap.has(key)) return true;
          } catch (err) {
            delete this.weakmap;
          }
          if (this.isSafeToReadWrite(key)) try {
            var entry = key[this.name];
            return !(!entry || entry[0] !== key);
          } catch (err) {
          }
          this._cleanupClosedWindows();
          return -1 !== util_safeIndexOf(this.keys, key);
        };
        _proto.getOrSet = function(key, getter) {
          if (this.has(key)) return this.get(key);
          var value = getter();
          this.set(key, value);
          return value;
        };
        return CrossDomainSafeWeakMap;
      })();
      function getFunctionName(fn) {
        return fn.name || fn.__name__ || fn.displayName || "anonymous";
      }
      function setFunctionName(fn, name) {
        try {
          delete fn.name;
          fn.name = name;
        } catch (err) {
        }
        fn.__name__ = fn.displayName = name;
        return fn;
      }
      function uniqueID() {
        var chars = "0123456789abcdef";
        return "uid_" + "xxxxxxxxxx".replace(/./g, (function() {
          return chars.charAt(Math.floor(Math.random() * chars.length));
        })) + "_" + (function(str) {
          if ("function" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {
            return String.fromCharCode(parseInt(p1, 16));
          }))).replace(/[=]/g, "");
          if ("undefined" != typeof Buffer) return Buffer.from(str, "utf8").toString("base64").replace(/[=]/g, "");
          throw new Error("Can not find window.btoa or Buffer");
        })((/* @__PURE__ */ new Date()).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
      }
      var objectIDs;
      function serializeArgs(args) {
        try {
          return JSON.stringify([].slice.call(args), (function(subkey, val) {
            return "function" == typeof val ? "memoize[" + (function(obj) {
              objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap();
              if (null == obj || "object" != typeof obj && "function" != typeof obj) throw new Error("Invalid object");
              var uid = objectIDs.get(obj);
              if (!uid) {
                uid = typeof obj + ":" + uniqueID();
                objectIDs.set(obj, uid);
              }
              return uid;
            })(val) + "]" : "undefined" != typeof window && val instanceof window.Element || null !== val && "object" == typeof val && 1 === val.nodeType && "object" == typeof val.style && "object" == typeof val.ownerDocument ? {} : val;
          }));
        } catch (err) {
          throw new Error("Arguments not serializable -- can not be used to memoize");
        }
      }
      function getEmptyObject() {
        return {};
      }
      var memoizeGlobalIndex = 0;
      var memoizeGlobalIndexValidFrom = 0;
      function memoize(method, options) {
        void 0 === options && (options = {});
        var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;
        var simpleCache;
        var thisCache;
        var memoizeIndex = memoizeGlobalIndex;
        memoizeGlobalIndex += 1;
        var memoizedFunction = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
          if (memoizeIndex < memoizeGlobalIndexValidFrom) {
            simpleCache = null;
            thisCache = null;
            memoizeIndex = memoizeGlobalIndex;
            memoizeGlobalIndex += 1;
          }
          var cache;
          cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap()).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};
          var cacheKey;
          try {
            cacheKey = serializeArgs(args);
          } catch (_unused) {
            return method.apply(this, arguments);
          }
          var cacheResult = cache[cacheKey];
          if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {
            delete cache[cacheKey];
            cacheResult = null;
          }
          if (cacheResult) return cacheResult.value;
          var time = Date.now();
          var value = method.apply(this, arguments);
          cache[cacheKey] = {
            time,
            value
          };
          return value;
        };
        memoizedFunction.reset = function() {
          simpleCache = null;
          thisCache = null;
        };
        return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + "::memoized");
      }
      memoize.clear = function() {
        memoizeGlobalIndexValidFrom = memoizeGlobalIndex;
      };
      function memoizePromise(method) {
        var cache = {};
        function memoizedPromiseFunction() {
          var _arguments = arguments, _this = this;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
          var key = serializeArgs(args);
          if (cache.hasOwnProperty(key)) return cache[key];
          cache[key] = promise_ZalgoPromise.try((function() {
            return method.apply(_this, _arguments);
          })).finally((function() {
            delete cache[key];
          }));
          return cache[key];
        }
        memoizedPromiseFunction.reset = function() {
          cache = {};
        };
        return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + "::promiseMemoized");
      }
      function src_util_noop() {
      }
      function stringifyError(err, level) {
        void 0 === level && (level = 1);
        if (level >= 3) return "stringifyError stack overflow";
        try {
          if (!err) return "<unknown error: " + {}.toString.call(err) + ">";
          if ("string" == typeof err) return err;
          if (err instanceof Error) {
            var stack = err && err.stack;
            var message = err && err.message;
            if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
            if (stack) return stack;
            if (message) return message;
          }
          return err && err.toString && "function" == typeof err.toString ? err.toString() : {}.toString.call(err);
        } catch (newErr) {
          return "Error while stringifying error: " + stringifyError(newErr, level + 1);
        }
      }
      function stringify(item) {
        return "string" == typeof item ? item : item && item.toString && "function" == typeof item.toString ? item.toString() : {}.toString.call(item);
      }
      memoize((function(obj) {
        if (Object.values) return Object.values(obj);
        var result = [];
        for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);
        return result;
      }));
      function util_isRegex(item) {
        return "[object RegExp]" === {}.toString.call(item);
      }
      function util_getOrSet(obj, key, getter) {
        if (obj.hasOwnProperty(key)) return obj[key];
        var val = getter();
        obj[key] = val;
        return val;
      }
      function getBody() {
        var body = document.body;
        if (!body) throw new Error("Body element not found");
        return body;
      }
      function isDocumentReady() {
        return Boolean(document.body) && "complete" === document.readyState;
      }
      function isDocumentInteractive() {
        return Boolean(document.body) && "interactive" === document.readyState;
      }
      memoize((function() {
        return new promise_ZalgoPromise((function(resolve) {
          if (isDocumentReady() || isDocumentInteractive()) return resolve();
          var interval = setInterval((function() {
            if (isDocumentReady() || isDocumentInteractive()) {
              clearInterval(interval);
              return resolve();
            }
          }), 10);
        }));
      }));
      var currentScript = "undefined" != typeof document ? document.currentScript : null;
      var getCurrentScript = memoize((function() {
        if (currentScript) return currentScript;
        if (currentScript = (function() {
          try {
            var stack = (function() {
              try {
                throw new Error("_");
              } catch (err) {
                return err.stack || "";
              }
            })();
            var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(stack);
            var scriptLocation = stackDetails && stackDetails[1];
            if (!scriptLocation) return;
            for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName("script")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {
              var script = _Array$prototype$slic2[_i22];
              if (script.src && script.src === scriptLocation) return script;
            }
          } catch (err) {
          }
        })()) return currentScript;
        throw new Error("Can not determine current script");
      }));
      var currentUID = uniqueID();
      memoize((function() {
        var script;
        try {
          script = getCurrentScript();
        } catch (err) {
          return currentUID;
        }
        var uid = script.getAttribute("data-uid");
        if (uid && "string" == typeof uid) return uid;
        if ((uid = script.getAttribute("data-uid-auto")) && "string" == typeof uid) return uid;
        if (script.src) {
          var hashedString = (function(str) {
            var hash = "";
            for (var i = 0; i < str.length; i++) {
              var total = str[i].charCodeAt(0) * i;
              str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));
              hash += String.fromCharCode(97 + Math.abs(total) % 26);
            }
            return hash;
          })(JSON.stringify({
            src: script.src,
            dataset: script.dataset
          }));
          uid = "uid_" + hashedString.slice(hashedString.length - 30);
        } else uid = uniqueID();
        script.setAttribute("data-uid-auto", uid);
        return uid;
      }));
      function global_getGlobal(win) {
        void 0 === win && (win = window);
        var globalKey = "__post_robot_10_0_46__";
        return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};
      }
      var getObj = function() {
        return {};
      };
      function globalStore(key, defStore) {
        void 0 === key && (key = "store");
        void 0 === defStore && (defStore = getObj);
        return util_getOrSet(global_getGlobal(), key, (function() {
          var store = defStore();
          return {
            has: function(storeKey) {
              return store.hasOwnProperty(storeKey);
            },
            get: function(storeKey, defVal) {
              return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;
            },
            set: function(storeKey, val) {
              store[storeKey] = val;
              return val;
            },
            del: function(storeKey) {
              delete store[storeKey];
            },
            getOrSet: function(storeKey, getter) {
              return util_getOrSet(store, storeKey, getter);
            },
            reset: function() {
              store = defStore();
            },
            keys: function() {
              return Object.keys(store);
            }
          };
        }));
      }
      var WildCard = function() {
      };
      function getWildcard() {
        var global2 = global_getGlobal();
        global2.WINDOW_WILDCARD = global2.WINDOW_WILDCARD || new WildCard();
        return global2.WINDOW_WILDCARD;
      }
      function windowStore(key, defStore) {
        void 0 === key && (key = "store");
        void 0 === defStore && (defStore = getObj);
        return globalStore("windowStore").getOrSet(key, (function() {
          var winStore = new weakmap_CrossDomainSafeWeakMap();
          var getStore = function(win) {
            return winStore.getOrSet(win, defStore);
          };
          return {
            has: function(win) {
              return getStore(win).hasOwnProperty(key);
            },
            get: function(win, defVal) {
              var store = getStore(win);
              return store.hasOwnProperty(key) ? store[key] : defVal;
            },
            set: function(win, val) {
              getStore(win)[key] = val;
              return val;
            },
            del: function(win) {
              delete getStore(win)[key];
            },
            getOrSet: function(win, getter) {
              return util_getOrSet(getStore(win), key, getter);
            }
          };
        }));
      }
      function getInstanceID() {
        return globalStore("instance").getOrSet("instanceID", uniqueID);
      }
      function resolveHelloPromise(win, _ref) {
        var domain = _ref.domain;
        var helloPromises = windowStore("helloPromises");
        var existingPromise = helloPromises.get(win);
        existingPromise && existingPromise.resolve({
          domain
        });
        var newPromise = promise_ZalgoPromise.resolve({
          domain
        });
        helloPromises.set(win, newPromise);
        return newPromise;
      }
      function sayHello(win, _ref4) {
        return (0, _ref4.send)(win, "postrobot_hello", {
          instanceID: getInstanceID()
        }, {
          domain: "*",
          timeout: -1
        }).then((function(_ref5) {
          var origin = _ref5.origin, instanceID = _ref5.data.instanceID;
          resolveHelloPromise(win, {
            domain: origin
          });
          return {
            win,
            domain: origin,
            instanceID
          };
        }));
      }
      function getWindowInstanceID(win, _ref6) {
        var send = _ref6.send;
        return windowStore("windowInstanceIDPromises").getOrSet(win, (function() {
          return sayHello(win, {
            send
          }).then((function(_ref7) {
            return _ref7.instanceID;
          }));
        }));
      }
      function markWindowKnown(win) {
        windowStore("knownWindows").set(win, true);
      }
      function isSerializedType(item) {
        return "object" == typeof item && null !== item && "string" == typeof item.__type__;
      }
      function determineType(val) {
        return void 0 === val ? "undefined" : null === val ? "null" : Array.isArray(val) ? "array" : "function" == typeof val ? "function" : "object" == typeof val ? val instanceof Error ? "error" : "function" == typeof val.then ? "promise" : "[object RegExp]" === {}.toString.call(val) ? "regex" : "[object Date]" === {}.toString.call(val) ? "date" : "object" : "string" == typeof val ? "string" : "number" == typeof val ? "number" : "boolean" == typeof val ? "boolean" : void 0;
      }
      function serializeType(type, val) {
        return {
          __type__: type,
          __val__: val
        };
      }
      var _SERIALIZER;
      var SERIALIZER = ((_SERIALIZER = {}).function = function() {
      }, _SERIALIZER.error = function(_ref) {
        return serializeType("error", {
          message: _ref.message,
          stack: _ref.stack,
          code: _ref.code,
          data: _ref.data
        });
      }, _SERIALIZER.promise = function() {
      }, _SERIALIZER.regex = function(val) {
        return serializeType("regex", val.source);
      }, _SERIALIZER.date = function(val) {
        return serializeType("date", val.toJSON());
      }, _SERIALIZER.array = function(val) {
        return val;
      }, _SERIALIZER.object = function(val) {
        return val;
      }, _SERIALIZER.string = function(val) {
        return val;
      }, _SERIALIZER.number = function(val) {
        return val;
      }, _SERIALIZER.boolean = function(val) {
        return val;
      }, _SERIALIZER.null = function(val) {
        return val;
      }, _SERIALIZER[void 0] = function(val) {
        return serializeType("undefined", val);
      }, _SERIALIZER);
      var defaultSerializers = {};
      var _DESERIALIZER;
      var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {
        throw new Error("Function serialization is not implemented; nothing to deserialize");
      }, _DESERIALIZER.error = function(_ref2) {
        var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;
        var error = new Error(_ref2.message);
        error.code = code;
        data && (error.data = data);
        error.stack = stack + "\n\n" + error.stack;
        return error;
      }, _DESERIALIZER.promise = function() {
        throw new Error("Promise serialization is not implemented; nothing to deserialize");
      }, _DESERIALIZER.regex = function(val) {
        return new RegExp(val);
      }, _DESERIALIZER.date = function(val) {
        return new Date(val);
      }, _DESERIALIZER.array = function(val) {
        return val;
      }, _DESERIALIZER.object = function(val) {
        return val;
      }, _DESERIALIZER.string = function(val) {
        return val;
      }, _DESERIALIZER.number = function(val) {
        return val;
      }, _DESERIALIZER.boolean = function(val) {
        return val;
      }, _DESERIALIZER.null = function(val) {
        return val;
      }, _DESERIALIZER[void 0] = function() {
      }, _DESERIALIZER);
      var defaultDeserializers = {};
      new promise_ZalgoPromise((function(resolve) {
        if (window.document && window.document.body) return resolve(window.document.body);
        var interval = setInterval((function() {
          if (window.document && window.document.body) {
            clearInterval(interval);
            return resolve(window.document.body);
          }
        }), 10);
      }));
      function cleanupProxyWindows() {
        var idToProxyWindow = globalStore("idToProxyWindow");
        for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {
          var id = _idToProxyWindow$keys2[_i2];
          idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);
        }
      }
      function getSerializedWindow(winPromise, _ref) {
        var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;
        var windowNamePromise = winPromise.then((function(win) {
          if (isSameDomain(win)) return assertSameDomain(win).name;
        }));
        var windowTypePromise = winPromise.then((function(window2) {
          if (isWindowClosed(window2)) throw new Error("Window is closed, can not determine type");
          return getOpener(window2) ? "popup" : "iframe";
        }));
        windowNamePromise.catch(src_util_noop);
        windowTypePromise.catch(src_util_noop);
        var getName = function() {
          return winPromise.then((function(win) {
            if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;
          }));
        };
        return {
          id,
          getType: function() {
            return windowTypePromise;
          },
          getInstanceID: memoizePromise((function() {
            return winPromise.then((function(win) {
              return getWindowInstanceID(win, {
                send
              });
            }));
          })),
          close: function() {
            return winPromise.then(closeWindow);
          },
          getName,
          focus: function() {
            return winPromise.then((function(win) {
              win.focus();
            }));
          },
          isClosed: function() {
            return winPromise.then((function(win) {
              return isWindowClosed(win);
            }));
          },
          setLocation: function(href, opts) {
            void 0 === opts && (opts = {});
            return winPromise.then((function(win) {
              var domain = window.location.protocol + "//" + window.location.host;
              var _opts$method = opts.method, method = void 0 === _opts$method ? "get" : _opts$method, body = opts.body;
              if (0 === href.indexOf("/")) href = "" + domain + href;
              else if (!href.match(/^https?:\/\//) && 0 !== href.indexOf(domain)) throw new Error("Expected url to be http or https url, or absolute path, got " + JSON.stringify(href));
              if ("post" === method) return getName().then((function(name) {
                if (!name) throw new Error("Can not post to window without target name");
                !(function(_ref3) {
                  var url = _ref3.url, target = _ref3.target, body2 = _ref3.body, _ref3$method = _ref3.method, method2 = void 0 === _ref3$method ? "post" : _ref3$method;
                  var form = document.createElement("form");
                  form.setAttribute("target", target);
                  form.setAttribute("method", method2);
                  form.setAttribute("action", url);
                  form.style.display = "none";
                  if (body2) for (var _i24 = 0, _Object$keys4 = Object.keys(body2); _i24 < _Object$keys4.length; _i24++) {
                    var _body$key;
                    var key = _Object$keys4[_i24];
                    var input = document.createElement("input");
                    input.setAttribute("name", key);
                    input.setAttribute("value", null == (_body$key = body2[key]) ? void 0 : _body$key.toString());
                    form.appendChild(input);
                  }
                  getBody().appendChild(form);
                  form.submit();
                  getBody().removeChild(form);
                })({
                  url: href,
                  target: name,
                  method,
                  body
                });
              }));
              if ("get" !== method) throw new Error("Unsupported method: " + method);
              if (isSameDomain(win)) try {
                if (win.location && "function" == typeof win.location.replace) {
                  win.location.replace(href);
                  return;
                }
              } catch (err) {
              }
              win.location = href;
            }));
          },
          setName: function(name) {
            return winPromise.then((function(win) {
              var sameDomain = isSameDomain(win);
              var frame = getFrameForWindow(win);
              if (!sameDomain) throw new Error("Can not set name for cross-domain window: " + name);
              assertSameDomain(win).name = name;
              frame && frame.setAttribute("name", name);
              windowNamePromise = promise_ZalgoPromise.resolve(name);
            }));
          }
        };
      }
      var window_ProxyWindow = (function() {
        function ProxyWindow(_ref2) {
          var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;
          this.id = void 0;
          this.isProxyWindow = true;
          this.serializedWindow = void 0;
          this.actualWindow = void 0;
          this.actualWindowPromise = void 0;
          this.send = void 0;
          this.name = void 0;
          this.actualWindowPromise = new promise_ZalgoPromise();
          this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {
            send
          });
          globalStore("idToProxyWindow").set(this.getID(), this);
          win && this.setWindow(win, {
            send
          });
        }
        var _proto = ProxyWindow.prototype;
        _proto.getID = function() {
          return this.serializedWindow.id;
        };
        _proto.getType = function() {
          return this.serializedWindow.getType();
        };
        _proto.isPopup = function() {
          return this.getType().then((function(type) {
            return "popup" === type;
          }));
        };
        _proto.setLocation = function(href, opts) {
          var _this = this;
          return this.serializedWindow.setLocation(href, opts).then((function() {
            return _this;
          }));
        };
        _proto.getName = function() {
          return this.serializedWindow.getName();
        };
        _proto.setName = function(name) {
          var _this2 = this;
          return this.serializedWindow.setName(name).then((function() {
            return _this2;
          }));
        };
        _proto.close = function() {
          var _this3 = this;
          return this.serializedWindow.close().then((function() {
            return _this3;
          }));
        };
        _proto.focus = function() {
          var _this4 = this;
          var isPopupPromise = this.isPopup();
          var getNamePromise = this.getName();
          var reopenPromise = promise_ZalgoPromise.hash({
            isPopup: isPopupPromise,
            name: getNamePromise
          }).then((function(_ref3) {
            var name = _ref3.name;
            _ref3.isPopup && name && window.open("", name, "noopener");
          }));
          var focusPromise = this.serializedWindow.focus();
          return promise_ZalgoPromise.all([reopenPromise, focusPromise]).then((function() {
            return _this4;
          }));
        };
        _proto.isClosed = function() {
          return this.serializedWindow.isClosed();
        };
        _proto.getWindow = function() {
          return this.actualWindow;
        };
        _proto.setWindow = function(win, _ref4) {
          var send = _ref4.send;
          this.actualWindow = win;
          this.actualWindowPromise.resolve(this.actualWindow);
          this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {
            send,
            id: this.getID()
          });
          windowStore("winToProxyWindow").set(win, this);
        };
        _proto.awaitWindow = function() {
          return this.actualWindowPromise;
        };
        _proto.matchWindow = function(win, _ref5) {
          var _this5 = this;
          var send = _ref5.send;
          return promise_ZalgoPromise.try((function() {
            return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({
              proxyInstanceID: _this5.getInstanceID(),
              knownWindowInstanceID: getWindowInstanceID(win, {
                send
              })
            }).then((function(_ref6) {
              var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;
              match && _this5.setWindow(win, {
                send
              });
              return match;
            }));
          }));
        };
        _proto.unwrap = function() {
          return this.actualWindow || this;
        };
        _proto.getInstanceID = function() {
          return this.serializedWindow.getInstanceID();
        };
        _proto.shouldClean = function() {
          return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));
        };
        _proto.serialize = function() {
          return this.serializedWindow;
        };
        ProxyWindow.unwrap = function(win) {
          return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;
        };
        ProxyWindow.serialize = function(win, _ref7) {
          var send = _ref7.send;
          cleanupProxyWindows();
          return ProxyWindow.toProxyWindow(win, {
            send
          }).serialize();
        };
        ProxyWindow.deserialize = function(serializedWindow, _ref8) {
          var send = _ref8.send;
          cleanupProxyWindows();
          return globalStore("idToProxyWindow").get(serializedWindow.id) || new ProxyWindow({
            serializedWindow,
            send
          });
        };
        ProxyWindow.isProxyWindow = function(obj) {
          return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);
        };
        ProxyWindow.toProxyWindow = function(win, _ref9) {
          var send = _ref9.send;
          cleanupProxyWindows();
          if (ProxyWindow.isProxyWindow(win)) return win;
          var actualWindow = win;
          return windowStore("winToProxyWindow").get(actualWindow) || new ProxyWindow({
            win: actualWindow,
            send
          });
        };
        return ProxyWindow;
      })();
      function addMethod(id, val, name, source, domain) {
        var methodStore = windowStore("methodStore");
        var proxyWindowMethods = globalStore("proxyWindowMethods");
        if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {
          val,
          name,
          domain,
          source
        });
        else {
          proxyWindowMethods.del(id);
          methodStore.getOrSet(source, (function() {
            return {};
          }))[id] = {
            domain,
            name,
            val,
            source
          };
        }
      }
      function lookupMethod(source, id) {
        var methodStore = windowStore("methodStore");
        var proxyWindowMethods = globalStore("proxyWindowMethods");
        return methodStore.getOrSet(source, (function() {
          return {};
        }))[id] || proxyWindowMethods.get(id);
      }
      function function_serializeFunction(destination, domain, val, key, _ref3) {
        on = (_ref = {
          on: _ref3.on,
          send: _ref3.send
        }).on, send = _ref.send, globalStore("builtinListeners").getOrSet("functionCalls", (function() {
          return on("postrobot_method", {
            domain: "*"
          }, (function(_ref2) {
            var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
            var id2 = data.id, name2 = data.name;
            var meth = lookupMethod(source, id2);
            if (!meth) throw new Error("Could not find method '" + name2 + "' with id: " + data.id + " in " + getDomain(window));
            var methodSource = meth.source, domain2 = meth.domain, val2 = meth.val;
            return promise_ZalgoPromise.try((function() {
              if (!matchDomain(domain2, origin)) throw new Error("Method '" + data.name + "' domain " + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + " does not match origin " + origin + " in " + getDomain(window));
              if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {
                send
              }).then((function(match) {
                if (!match) throw new Error("Method call '" + data.name + "' failed - proxy window does not match source in " + getDomain(window));
              }));
            })).then((function() {
              return val2.apply({
                source,
                origin
              }, data.args);
            }), (function(err) {
              return promise_ZalgoPromise.try((function() {
                if (val2.onError) return val2.onError(err);
              })).then((function() {
                err.stack && (err.stack = "Remote call to " + name2 + "(" + (function(args) {
                  void 0 === args && (args = []);
                  return (item = args, [].slice.call(item)).map((function(arg) {
                    return "string" == typeof arg ? "'" + arg + "'" : void 0 === arg ? "undefined" : null === arg ? "null" : "boolean" == typeof arg ? arg.toString() : Array.isArray(arg) ? "[ ... ]" : "object" == typeof arg ? "{ ... }" : "function" == typeof arg ? "() => { ... }" : "<" + typeof arg + ">";
                  })).join(", ");
                  var item;
                })(data.args) + ") failed\n\n" + err.stack);
                throw err;
              }));
            })).then((function(result) {
              return {
                result,
                id: id2,
                name: name2
              };
            }));
          }));
        }));
        var _ref, on, send;
        var id = val.__id__ || uniqueID();
        destination = window_ProxyWindow.unwrap(destination);
        var name = val.__name__ || val.name || key;
        "string" == typeof name && "function" == typeof name.indexOf && 0 === name.indexOf("anonymous::") && (name = name.replace("anonymous::", key + "::"));
        if (window_ProxyWindow.isProxyWindow(destination)) {
          addMethod(id, val, name, destination, domain);
          destination.awaitWindow().then((function(win) {
            addMethod(id, val, name, win, domain);
          }));
        } else addMethod(id, val, name, destination, domain);
        return serializeType("cross_domain_function", {
          id,
          name
        });
      }
      function serializeMessage(destination, domain, obj, _ref) {
        var _serialize;
        var on = _ref.on, send = _ref.send;
        return (function(obj2, serializers) {
          void 0 === serializers && (serializers = defaultSerializers);
          var result = JSON.stringify(obj2, (function(key) {
            var val = this[key];
            if (isSerializedType(this)) return val;
            var type = determineType(val);
            if (!type) return val;
            var serializer = serializers[type] || SERIALIZER[type];
            return serializer ? serializer(val, key) : val;
          }));
          return void 0 === result ? "undefined" : result;
        })(obj, ((_serialize = {}).promise = function(val, key) {
          return (function(destination2, domain2, val2, key2, _ref2) {
            return serializeType("cross_domain_zalgo_promise", {
              then: function_serializeFunction(destination2, domain2, (function(resolve, reject) {
                return val2.then(resolve, reject);
              }), key2, {
                on: _ref2.on,
                send: _ref2.send
              })
            });
          })(destination, domain, val, key, {
            on,
            send
          });
        }, _serialize.function = function(val, key) {
          return function_serializeFunction(destination, domain, val, key, {
            on,
            send
          });
        }, _serialize.object = function(val) {
          return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType("cross_domain_window", window_ProxyWindow.serialize(val, {
            send
          })) : val;
        }, _serialize));
      }
      function deserializeMessage(source, origin, message, _ref2) {
        var _deserialize;
        var send = _ref2.send;
        return (function(str, deserializers) {
          void 0 === deserializers && (deserializers = defaultDeserializers);
          if ("undefined" !== str) return JSON.parse(str, (function(key, val) {
            if (isSerializedType(this)) return val;
            var type;
            var value;
            if (isSerializedType(val)) {
              type = val.__type__;
              value = val.__val__;
            } else {
              type = determineType(val);
              value = val;
            }
            if (!type) return value;
            var deserializer = deserializers[type] || DESERIALIZER[type];
            return deserializer ? deserializer(value, key) : value;
          }));
        })(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {
          return (function(source2, origin2, _ref22) {
            return new promise_ZalgoPromise(_ref22.then);
          })(0, 0, serializedPromise);
        }, _deserialize.cross_domain_function = function(serializedFunction) {
          return (function(source2, origin2, _ref4, _ref5) {
            var id = _ref4.id, name = _ref4.name;
            var send2 = _ref5.send;
            var getDeserializedFunction = function(opts) {
              void 0 === opts && (opts = {});
              function crossDomainFunctionWrapper2() {
                var _arguments = arguments;
                return window_ProxyWindow.toProxyWindow(source2, {
                  send: send2
                }).awaitWindow().then((function(win) {
                  var meth = lookupMethod(win, id);
                  if (meth && meth.val !== crossDomainFunctionWrapper2) return meth.val.apply({
                    source: window,
                    origin: getDomain()
                  }, _arguments);
                  var _args = [].slice.call(_arguments);
                  return opts.fireAndForget ? send2(win, "postrobot_method", {
                    id,
                    name,
                    args: _args
                  }, {
                    domain: origin2,
                    fireAndForget: true
                  }) : send2(win, "postrobot_method", {
                    id,
                    name,
                    args: _args
                  }, {
                    domain: origin2,
                    fireAndForget: false
                  }).then((function(res) {
                    return res.data.result;
                  }));
                })).catch((function(err) {
                  throw err;
                }));
              }
              crossDomainFunctionWrapper2.__name__ = name;
              crossDomainFunctionWrapper2.__origin__ = origin2;
              crossDomainFunctionWrapper2.__source__ = source2;
              crossDomainFunctionWrapper2.__id__ = id;
              crossDomainFunctionWrapper2.origin = origin2;
              return crossDomainFunctionWrapper2;
            };
            var crossDomainFunctionWrapper = getDeserializedFunction();
            crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({
              fireAndForget: true
            });
            return crossDomainFunctionWrapper;
          })(source, origin, serializedFunction, {
            send
          });
        }, _deserialize.cross_domain_window = function(serializedWindow) {
          return window_ProxyWindow.deserialize(serializedWindow, {
            send
          });
        }, _deserialize));
      }
      var SEND_MESSAGE_STRATEGIES = {};
      SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {
        0 === domain.indexOf("file:") && (domain = "*");
        win.postMessage(serializedMessage, domain);
      };
      function send_sendMessage(win, domain, message, _ref2) {
        var on = _ref2.on, send = _ref2.send;
        return promise_ZalgoPromise.try((function() {
          var domainBuffer = windowStore().getOrSet(win, (function() {
            return {};
          }));
          domainBuffer.buffer = domainBuffer.buffer || [];
          domainBuffer.buffer.push(message);
          domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {
            if (isWindowClosed(win)) throw new Error("Window is closed");
            var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], _ref), {
              on,
              send
            });
            var _ref;
            delete domainBuffer.buffer;
            var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);
            var errors = [];
            for (var _i2 = 0; _i2 < strategies.length; _i2++) {
              var strategyName = strategies[_i2];
              try {
                SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);
              } catch (err) {
                errors.push(err);
              }
            }
            if (errors.length === strategies.length) throw new Error("All post-robot messaging strategies failed:\n\n" + errors.map((function(err, i) {
              return i + ". " + stringifyError(err);
            })).join("\n\n"));
          }));
          return domainBuffer.flush.then((function() {
            delete domainBuffer.flush;
          }));
        })).then(src_util_noop);
      }
      function getResponseListener(hash) {
        return globalStore("responseListeners").get(hash);
      }
      function deleteResponseListener(hash) {
        globalStore("responseListeners").del(hash);
      }
      function isResponseListenerErrored(hash) {
        return globalStore("erroredResponseListeners").has(hash);
      }
      function getRequestListener(_ref) {
        var name = _ref.name, win = _ref.win, domain = _ref.domain;
        var requestListeners = windowStore("requestListeners");
        "*" === win && (win = null);
        "*" === domain && (domain = null);
        if (!name) throw new Error("Name required to get request listener");
        for (var _i4 = 0, _ref3 = [win, getWildcard()]; _i4 < _ref3.length; _i4++) {
          var winQualifier = _ref3[_i4];
          if (winQualifier) {
            var nameListeners = requestListeners.get(winQualifier);
            if (nameListeners) {
              var domainListeners = nameListeners[name];
              if (domainListeners) {
                if (domain && "string" == typeof domain) {
                  if (domainListeners[domain]) return domainListeners[domain];
                  if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {
                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;
                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;
                  }
                }
                if (domainListeners["*"]) return domainListeners["*"];
              }
            }
          }
        }
      }
      function handleRequest(source, origin, message, _ref) {
        var on = _ref.on, send = _ref.send;
        var options = getRequestListener({
          name: message.name,
          win: source,
          domain: origin
        });
        var logName = "postrobot_method" === message.name && message.data && "string" == typeof message.data.name ? message.data.name + "()" : message.name;
        function sendResponse(ack, data, error) {
          return promise_ZalgoPromise.flush().then((function() {
            if (!message.fireAndForget && !isWindowClosed(source)) try {
              return send_sendMessage(source, origin, {
                id: uniqueID(),
                origin: getDomain(window),
                type: "postrobot_message_response",
                hash: message.hash,
                name: message.name,
                ack,
                data,
                error
              }, {
                on,
                send
              });
            } catch (err) {
              throw new Error("Send response message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
            }
          }));
        }
        return promise_ZalgoPromise.all([promise_ZalgoPromise.flush().then((function() {
          if (!message.fireAndForget && !isWindowClosed(source)) try {
            return send_sendMessage(source, origin, {
              id: uniqueID(),
              origin: getDomain(window),
              type: "postrobot_message_ack",
              hash: message.hash,
              name: message.name
            }, {
              on,
              send
            });
          } catch (err) {
            throw new Error("Send ack message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
          }
        })), promise_ZalgoPromise.try((function() {
          if (!options) throw new Error("No handler found for post message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
          return options.handler({
            source,
            origin,
            data: message.data
          });
        })).then((function(data) {
          return sendResponse("success", data);
        }), (function(error) {
          return sendResponse("error", null, error);
        }))]).then(src_util_noop).catch((function(err) {
          if (options && options.handleError) return options.handleError(err);
          throw err;
        }));
      }
      function handleAck(source, origin, message) {
        if (!isResponseListenerErrored(message.hash)) {
          var options = getResponseListener(message.hash);
          if (!options) throw new Error("No handler found for post message ack for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
          try {
            if (!matchDomain(options.domain, origin)) throw new Error("Ack origin " + origin + " does not match domain " + options.domain.toString());
            if (source !== options.win) throw new Error("Ack source does not match registered window");
          } catch (err) {
            options.promise.reject(err);
          }
          options.ack = true;
        }
      }
      function handleResponse(source, origin, message) {
        if (!isResponseListenerErrored(message.hash)) {
          var options = getResponseListener(message.hash);
          if (!options) throw new Error("No handler found for post message response for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
          if (!matchDomain(options.domain, origin)) throw new Error("Response origin " + origin + " does not match domain " + (pattern = options.domain, Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : isRegex(pattern) ? "RegExp(" + pattern.toString() + ")" : pattern.toString()));
          var pattern;
          if (source !== options.win) throw new Error("Response source does not match registered window");
          deleteResponseListener(message.hash);
          "error" === message.ack ? options.promise.reject(message.error) : "success" === message.ack && options.promise.resolve({
            source,
            origin,
            data: message.data
          });
        }
      }
      function receive_receiveMessage(event, _ref2) {
        var on = _ref2.on, send = _ref2.send;
        var receivedMessages = globalStore("receivedMessages");
        try {
          if (!window || window.closed || !event.source) return;
        } catch (err) {
          return;
        }
        var source = event.source, origin = event.origin;
        var messages = (function(message2, source2, origin2, _ref) {
          var on2 = _ref.on, send2 = _ref.send;
          var parsedMessage;
          try {
            parsedMessage = deserializeMessage(source2, origin2, message2, {
              on: on2,
              send: send2
            });
          } catch (err) {
            return;
          }
          if (parsedMessage && "object" == typeof parsedMessage && null !== parsedMessage) {
            var parseMessages = parsedMessage.__post_robot_10_0_46__;
            if (Array.isArray(parseMessages)) return parseMessages;
          }
        })(event.data, source, origin, {
          on,
          send
        });
        if (messages) {
          markWindowKnown(source);
          for (var _i2 = 0; _i2 < messages.length; _i2++) {
            var message = messages[_i2];
            if (receivedMessages.has(message.id)) return;
            receivedMessages.set(message.id, true);
            if (isWindowClosed(source) && !message.fireAndForget) return;
            0 === message.origin.indexOf("file:") && (origin = "file://");
            try {
              "postrobot_message_request" === message.type ? handleRequest(source, origin, message, {
                on,
                send
              }) : "postrobot_message_response" === message.type ? handleResponse(source, origin, message) : "postrobot_message_ack" === message.type && handleAck(source, origin, message);
            } catch (err) {
              setTimeout((function() {
                throw err;
              }), 0);
            }
          }
        }
      }
      function on_on(name, options, handler) {
        if (!name) throw new Error("Expected name");
        if ("function" == typeof (options = options || {})) {
          handler = options;
          options = {};
        }
        if (!handler) throw new Error("Expected handler");
        var requestListener = (function addRequestListener(_ref4, listener) {
          var name2 = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;
          var requestListeners = windowStore("requestListeners");
          if (!name2 || "string" != typeof name2) throw new Error("Name required to add request listener");
          if (winCandidate && "*" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {
            var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {
              return addRequestListener({
                name: name2,
                win: actualWin,
                domain
              }, listener);
            }));
            return {
              cancel: function() {
                requestListenerPromise.then((function(requestListener2) {
                  return requestListener2.cancel();
                }), src_util_noop);
              }
            };
          }
          var win = winCandidate;
          if (Array.isArray(win)) {
            var listenersCollection = [];
            for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({
              name: name2,
              domain,
              win: _win2[_i8]
            }, listener));
            return {
              cancel: function() {
                for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();
              }
            };
          }
          if (Array.isArray(domain)) {
            var _listenersCollection = [];
            for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({
              name: name2,
              win,
              domain: _domain2[_i12]
            }, listener));
            return {
              cancel: function() {
                for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();
              }
            };
          }
          var existingListener = getRequestListener({
            name: name2,
            win,
            domain
          });
          win && "*" !== win || (win = getWildcard());
          var strDomain = (domain = domain || "*").toString();
          if (existingListener) throw win && domain ? new Error("Request listener already exists for " + name2 + " on domain " + domain.toString() + " for " + (win === getWildcard() ? "wildcard" : "specified") + " window") : win ? new Error("Request listener already exists for " + name2 + " for " + (win === getWildcard() ? "wildcard" : "specified") + " window") : domain ? new Error("Request listener already exists for " + name2 + " on domain " + domain.toString()) : new Error("Request listener already exists for " + name2);
          var winNameListeners = requestListeners.getOrSet(win, (function() {
            return {};
          }));
          var winNameDomainListeners = util_getOrSet(winNameListeners, name2, (function() {
            return {};
          }));
          var winNameDomainRegexListeners;
          var winNameDomainRegexListener;
          util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, "__domain_regex__", (function() {
            return [];
          }))).push(winNameDomainRegexListener = {
            regex: domain,
            listener
          }) : winNameDomainListeners[strDomain] = listener;
          return {
            cancel: function() {
              delete winNameDomainListeners[strDomain];
              if (winNameDomainRegexListener) {
                winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));
                winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;
              }
              Object.keys(winNameDomainListeners).length || delete winNameListeners[name2];
              win && !Object.keys(winNameListeners).length && requestListeners.del(win);
            }
          };
        })({
          name,
          win: options.window,
          domain: options.domain || "*"
        }, {
          handler: handler || options.handler,
          handleError: options.errorHandler || function(err) {
            throw err;
          }
        });
        return {
          cancel: function() {
            requestListener.cancel();
          }
        };
      }
      function on_once(name, options, handler) {
        if ("function" == typeof (options = options || {})) {
          handler = options;
          options = {};
        }
        var promise = new promise_ZalgoPromise();
        var listener;
        options.errorHandler = function(err) {
          listener.cancel();
          promise.reject(err);
        };
        listener = on_on(name, options, (function(event) {
          listener.cancel();
          promise.resolve(event);
          if (handler) return handler(event);
        }));
        promise.cancel = listener.cancel;
        return promise;
      }
      var send_send = function send(winOrProxyWin, name, data, options) {
        var domainMatcher = (options = options || {}).domain || "*";
        var responseTimeout = options.timeout || -1;
        var childTimeout = options.timeout || 5e3;
        var fireAndForget = options.fireAndForget || false;
        return window_ProxyWindow.toProxyWindow(winOrProxyWin, {
          send
        }).awaitWindow().then((function(win) {
          return promise_ZalgoPromise.try((function() {
            !(function(name2, win2, domain) {
              if (!name2) throw new Error("Expected name");
              if (domain && "string" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError("Can not send " + name2 + ". Expected domain " + JSON.stringify(domain) + " to be a string, array, or regex");
              if (isWindowClosed(win2)) throw new Error("Can not send " + name2 + ". Target window is closed");
            })(name, win, domainMatcher);
            if ((function(parent, child) {
              var actualParent = getAncestor(child);
              if (actualParent) return actualParent === parent;
              if (child === parent) return false;
              if ((function(win2) {
                void 0 === win2 && (win2 = window);
                try {
                  if (win2.top) return win2.top;
                } catch (err) {
                }
                if (getParent(win2) === win2) return win2;
                try {
                  if (isAncestorParent(window, win2) && window.top) return window.top;
                } catch (err) {
                }
                try {
                  if (isAncestorParent(win2, window) && window.top) return window.top;
                } catch (err) {
                }
                for (var _i7 = 0, _getAllChildFrames4 = (function getAllChildFrames(win3) {
                  var result = [];
                  for (var _i3 = 0, _getFrames2 = getFrames(win3); _i3 < _getFrames2.length; _i3++) {
                    var frame2 = _getFrames2[_i3];
                    result.push(frame2);
                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame2); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);
                  }
                  return result;
                })(win2); _i7 < _getAllChildFrames4.length; _i7++) {
                  var frame = _getAllChildFrames4[_i7];
                  try {
                    if (frame.top) return frame.top;
                  } catch (err) {
                  }
                  if (getParent(frame) === frame) return frame;
                }
              })(child) === child) return false;
              for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return true;
              return false;
            })(window, win)) return (function(win2, timeout, name2) {
              void 0 === timeout && (timeout = 5e3);
              void 0 === name2 && (name2 = "Window");
              var promise = (function(win3) {
                return windowStore("helloPromises").getOrSet(win3, (function() {
                  return new promise_ZalgoPromise();
                }));
              })(win2);
              -1 !== timeout && (promise = promise.timeout(timeout, new Error(name2 + " did not load after " + timeout + "ms")));
              return promise;
            })(win, childTimeout);
          })).then((function(_temp) {
            return (function(win2, targetDomain, actualDomain, _ref) {
              var send2 = _ref.send;
              return promise_ZalgoPromise.try((function() {
                return "string" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {
                  return actualDomain || sayHello(win2, {
                    send: send2
                  }).then((function(_ref2) {
                    return _ref2.domain;
                  }));
                })).then((function(normalizedDomain) {
                  if (!matchDomain(targetDomain, targetDomain)) throw new Error("Domain " + stringify(targetDomain) + " does not match " + stringify(targetDomain));
                  return normalizedDomain;
                }));
              }));
            })(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {
              send
            });
          })).then((function(targetDomain) {
            var domain = targetDomain;
            var logName = "postrobot_method" === name && data && "string" == typeof data.name ? data.name + "()" : name;
            var promise = new promise_ZalgoPromise();
            var hash = name + "_" + uniqueID();
            if (!fireAndForget) {
              var responseListener = {
                name,
                win,
                domain,
                promise
              };
              !(function(hash2, listener) {
                globalStore("responseListeners").set(hash2, listener);
              })(hash, responseListener);
              var reqPromises = windowStore("requestPromises").getOrSet(win, (function() {
                return [];
              }));
              reqPromises.push(promise);
              promise.catch((function() {
                !(function(hash2) {
                  globalStore("erroredResponseListeners").set(hash2, true);
                })(hash);
                deleteResponseListener(hash);
              }));
              var totalAckTimeout = (function(win2) {
                return windowStore("knownWindows").get(win2, false);
              })(win) ? 1e4 : 2e3;
              var totalResTimeout = responseTimeout;
              var ackTimeout = totalAckTimeout;
              var resTimeout = totalResTimeout;
              var interval = (function(method, time) {
                var timeout;
                !(function loop() {
                  timeout = setTimeout((function() {
                    !(function() {
                      if (isWindowClosed(win)) return promise.reject(new Error("Window closed for " + name + " before " + (responseListener.ack ? "response" : "ack")));
                      if (responseListener.cancelled) return promise.reject(new Error("Response listener was cancelled for " + name));
                      ackTimeout = Math.max(ackTimeout - 500, 0);
                      -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));
                      responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error("No response for postMessage " + logName + " in " + getDomain() + " in " + totalResTimeout + "ms")) : promise.reject(new Error("No ack for postMessage " + logName + " in " + getDomain() + " in " + totalAckTimeout + "ms"));
                    })();
                    loop();
                  }), 500);
                })();
                return {
                  cancel: function() {
                    clearTimeout(timeout);
                  }
                };
              })();
              promise.finally((function() {
                interval.cancel();
                reqPromises.splice(reqPromises.indexOf(promise, 1));
              })).catch(src_util_noop);
            }
            return send_sendMessage(win, domain, {
              id: uniqueID(),
              origin: getDomain(window),
              type: "postrobot_message_request",
              hash,
              name,
              data,
              fireAndForget
            }, {
              on: on_on,
              send
            }).then((function() {
              return fireAndForget ? promise.resolve() : promise;
            }), (function(err) {
              throw new Error("Send request message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
            }));
          }));
        }));
      };
      function setup_serializeMessage(destination, domain, obj) {
        return serializeMessage(destination, domain, obj, {
          on: on_on,
          send: send_send
        });
      }
      function setup_deserializeMessage(source, origin, message) {
        return deserializeMessage(source, origin, message, {
          on: on_on,
          send: send_send
        });
      }
      function createProxyWindow(win) {
        return new window_ProxyWindow({
          send: send_send,
          win
        });
      }
      function setup_toProxyWindow(win) {
        return window_ProxyWindow.toProxyWindow(win, {
          send: send_send
        });
      }
      function setup() {
        if (!global_getGlobal().initialized) {
          global_getGlobal().initialized = true;
          on = (_ref3 = {
            on: on_on,
            send: send_send
          }).on, send = _ref3.send, (global2 = global_getGlobal()).receiveMessage = global2.receiveMessage || function(message) {
            return receive_receiveMessage(message, {
              on,
              send
            });
          };
          !(function(_ref5) {
            var on2 = _ref5.on, send2 = _ref5.send;
            globalStore().getOrSet("postMessageListener", (function() {
              return (function(obj, event, handler) {
                obj.addEventListener("message", handler);
                return {
                  cancel: function() {
                    obj.removeEventListener("message", handler);
                  }
                };
              })(window, 0, (function(event) {
                !(function(event2, _ref4) {
                  var on3 = _ref4.on, send3 = _ref4.send;
                  promise_ZalgoPromise.try((function() {
                    var source = event2.source || event2.sourceElement;
                    var origin = event2.origin || event2.originalEvent && event2.originalEvent.origin;
                    var data = event2.data;
                    "null" === origin && (origin = "file://");
                    if (source) {
                      if (!origin) throw new Error("Post message did not have origin domain");
                      receive_receiveMessage({
                        source,
                        origin,
                        data
                      }, {
                        on: on3,
                        send: send3
                      });
                    }
                  }));
                })(event, {
                  on: on2,
                  send: send2
                });
              }));
            }));
          })({
            on: on_on,
            send: send_send
          });
          !(function(_ref8) {
            var on2 = _ref8.on, send2 = _ref8.send;
            globalStore("builtinListeners").getOrSet("helloListener", (function() {
              var listener = on2("postrobot_hello", {
                domain: "*"
              }, (function(_ref32) {
                resolveHelloPromise(_ref32.source, {
                  domain: _ref32.origin
                });
                return {
                  instanceID: getInstanceID()
                };
              }));
              var parent = getAncestor();
              parent && sayHello(parent, {
                send: send2
              }).catch((function(err) {
              }));
              return listener;
            }));
          })({
            on: on_on,
            send: send_send
          });
        }
        var _ref3, on, send, global2;
      }
      function destroy() {
        !(function() {
          var responseListeners = globalStore("responseListeners");
          for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {
            var hash = _responseListeners$ke2[_i2];
            var listener2 = responseListeners.get(hash);
            listener2 && (listener2.cancelled = true);
            responseListeners.del(hash);
          }
        })();
        (listener = globalStore().get("postMessageListener")) && listener.cancel();
        var listener;
        delete window.__post_robot_10_0_46__;
      }
      var src_types_TYPES_0 = true;
      function cleanUpWindow(win) {
        for (var _i2 = 0, _requestPromises$get2 = windowStore("requestPromises").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error("Window " + (isWindowClosed(win) ? "closed" : "cleaned up") + " before response")).catch(src_util_noop);
      }
      setup();
    }]);
  }));
})(postRobot);
var postRobotExports$1 = postRobot.exports;
(function(module) {
  module.exports = postRobotExports$1;
  module.exports.default = module.exports;
})(postRobot$1);
var postRobotExports = postRobot$1.exports;
var index = getDefaultExportFromCjs(postRobotExports);
var index$1 = _mergeNamespaces({
  __proto__: null,
  default: index
}, [postRobotExports]);
export {
  index$1 as i
};
//# sourceMappingURL=index-DD_kndDs-5QCJJDDY.js.map
